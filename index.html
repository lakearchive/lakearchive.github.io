<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>cunny</title>
<style>
* {margin:0;padding:0;outline:none;border:none}

body {
	font-family: sans-serif;
	background: var(--bg);
	color: var(--fg);
	margin: 0;
	font-size: 1rem;
	--accent: #63b3ff;
	--bg: #161616;
	--fg: #dde1e6;
	overflow: hidden;
}

canvas {
	background:#f8f4f0;
	display: block;
	image-rendering: pixelated;
	width: 100%;
	height: 100%;
}

.toolbar {
	position: fixed;
	bottom: 1em;
	left: 1em;
	padding: 10px;
	background-color: color-mix(in oklab, var(--bg), white 10%);
	border-radius: 7px;
	display: flex;
	flex-direction: horizontal;
	gap: 20px;
	align-items: center;
}

input[type=file] {opacity:0;position:absolute;width:0;height:0;}

.button {
	border-radius: 7px;
	background-color: var(--accent);
	color: var(--bg);
	padding: 10px;
	font-family: sans-serif;
}

.button:hover { cursor: pointer; }
.button:active { background: color-mix(in oklab, var(--accent), black 10%); }

.toolbar * { min-width: fit-content }

.menu {
	position: fixed;
	background-color: color-mix(in oklab, var(--bg), white 10%);
	padding: 10px;
	border-radius: 7px;
	display: flex;
	flex-direction: column;
	gap: 10px;
}

.menu > div {
	background-color: color-mix(in oklab, var(--bg), white 15%);
	border-radius: 7px;
	padding: 5px;
	cursor: pointer;
}

input[type=range] {
	min-width: 30vw;
}

dialog {
	display: grid;
	place-self: center;
	max-width: 33vw;
	max-height: 50vh;
}

#timestamp {
	font-family: monospace;
}
</style>
</head>
<body>
	<div id="toolbar" class="toolbar">
		<input type="file" id="fileInput" accept=".wpls" multiple/>
		<label for="fileInput" class="button">select file</label>
		<div>time: <span id="timestamp">go select a file</span></div>
		<input type="range" id="frameSlider" min="0" max="0" value="0" style="width:100%" />
		<button class="button" id="menuButton">â€¦</div>
	</div>
	<canvas id="canvas"></canvas>
	<div id="menu" class="menu">
		<div onmousedown="renderPerfectFrame()">render perfect image</div>
		<div onmousedown="renderDeltaHeatmap()">render heatmap</div>
		<div onmousedown="resetTransforms()">reset position</div>
		<div onmousedown="goToTimestamp()">go to timestamp</div>
		<div onmousedown="hideUi()">hide ui</div>
	</div>
	<dialog id="modal"></dialog>
<script src="./pako.min.js"></script>
<script src="./wpls.js"></script>
<script>
const canvas = document.getElementById("canvas"),
	ctx = canvas.getContext("2d"),
	fileInput = document.getElementById("fileInput"),
	timestampDisplay = document.getElementById("timestamp"),
	frameSlider = document.getElementById("frameSlider"),
	modal = document.getElementById("modal"),
	menuButton = document.getElementById("menuButton"),
	menu = document.getElementById("menu"),
	toolbar = document.getElementById("toolbar");

let wplsFiles = [],
	maxFrames = 0,
	dx = 0,
	dy = 0,
	mx = 0,
	my = 0,
	lastCutoffTs = 0;

const pixelCache = new Map(),
	pixelBuffers = new Map();

fileInput.addEventListener("change", async (e) => {
	const files = Array.from(e.target.files);
	wplsFiles = [];

	for (const file of files) {
		const buf = new Uint8Array(await file.arrayBuffer());
		const wpls = new WplsFile(buf);
		wplsFiles.push(wpls);
	}

	let earliestTs = Infinity, latestTs = -Infinity, minx = Infinity, miny = Infinity, maxx = -Infinity, maxy = -Infinity;

	for (const file of wplsFiles) {
		const { baseTimestamp, latestTimestamp, x, y } = file.metadata;
		if (baseTimestamp < earliestTs) earliestTs = baseTimestamp;
		if (latestTimestamp > latestTs) latestTs = latestTimestamp;
		if (x < minx) minx = x;
		if (x > maxx) maxx = x;
		if (y < miny) miny = y;
		if (y > maxy) maxy = y;
	}

	frameSlider.min = earliestTs;
	frameSlider.max = latestTs;
	frameSlider.value = latestTs;
	dx = minx;
	mx = maxx;
	dy = miny;
	my = maxy;

	timestampDisplay.innerText = formatDate(latestTs * 1000);

	pixelCache.clear();
	pixelBuffers.clear();

	renderFrame(latestTs);
});

frameSlider.addEventListener("input", debounce(() => {
	const timestamp = Number(frameSlider.value);
	renderFrame(timestamp);
	timestampDisplay.innerText = formatDate(timestamp * 1000);
}, 10));

let trX = 0,
	trY = 0,
	scale = 1;

const pointers = new Map();

canvas.addEventListener("pointerdown", e => {
	e.preventDefault();
	canvas.setPointerCapture(e.pointerId);
	pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
});

canvas.addEventListener("pointermove", e => {
	if (!pointers.has(e.pointerId)) return;
	const prev = pointers.get(e.pointerId);
	pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
	if (pointers.size === 1) {
		const dx = e.clientX - prev.x;
		const dy = e.clientY - prev.y;
		trX += dx;
		trY += dy;
		scheduleRender(Number(frameSlider.value));
	}/* else if (pointers.size === 2) {
		// todo
	}*/
});

canvas.addEventListener("pointerup", e => pointers.delete(e.pointerId));
canvas.addEventListener("pointercancel", e => pointers.delete(e.pointerId));

canvas.addEventListener("wheel", e => {
	e.preventDefault();

	const rect = canvas.getBoundingClientRect(),
		mouseX = e.clientX - rect.left,
		mouseY = e.clientY - rect.top;

	// world coords of cursor BEFORE zoom
	const worldX = (mouseX - trX) / scale,
		worldY = (mouseY - trY) / scale;

	const zoomFactor = e.deltaY < 0 ? 1.111 : 1 / 1.111;
	scale *= zoomFactor;

	// so that worldX/worldY stays under cursor
	trX = mouseX - worldX * scale;
	trY = mouseY - worldY * scale;

	scheduleRender(Number(frameSlider.value));
});


let needsRedraw = false;
function scheduleRender(cutoffTs) {
	lastCutoffTs = cutoffTs;
	if (!needsRedraw) {
		needsRedraw = true;
		requestAnimationFrame(() => {
			needsRedraw = false;
			renderFrame(lastCutoffTs);
		});
	}
}

function renderFrame(cutoffTs) {
	ctx.setTransform(1, 0, 0, 1, 0, 0);
	ctx.clearRect(0, 0, canvas.width, canvas.height);

	ctx.setTransform(scale, 0, 0, scale, trX|0, trY|0);
	ctx.imageSmoothingEnabled = false;

	// compute visible world rect
	const viewX0 = -trX / scale,
		viewY0 = -trY / scale,
		viewX1 = (canvas.width - trX) / scale,
		viewY1 = (canvas.height - trY) / scale;

	for (const wpls of wplsFiles) {
		if (wpls.metadata.baseTimestamp > cutoffTs) continue;

		const x = (wpls.metadata.x - dx) * 1000;
		const y = (wpls.metadata.y - dy) * 1000;

		if (x + 1000 < viewX0 || x > viewX1 || y + 1000 < viewY0 || y > viewY1)
			continue;

		let currentTs = -1;
		for (const [timestamp] of wpls.deltas) {
			if (timestamp > cutoffTs) break;
			currentTs = timestamp;
		}

		const k = wpls.metadata.x + "_" + wpls.metadata.y;
		let pixels = pixelCache.get(k),
			buf = pixelBuffers.get(k);

		if (!buf) {
			buf = new Uint8ClampedArray(1000*1000*4);
			pixelBuffers.set(k, buf);
		}

		if (!pixels) {
			wpls.toPng(currentTs, buf);

			const off = new OffscreenCanvas(1000, 1000),
				offCtx = off.getContext("2d"),
				imageData = new ImageData(buf, 1000, 1000);
			offCtx.imageSmoothingEnabled = false;
			offCtx.putImageData(imageData, 0, 0);
			off.timestamp = currentTs;
			pixels = off;
			pixelCache.set(k, pixels);
		} else if (pixels.timestamp !== currentTs) {
			wpls.toPng(currentTs, buf);

			const offCtx = pixels.getContext("2d"),
				imageData = new ImageData(buf, 1000, 1000);
			offCtx.clearRect(0, 0, pixels.width, pixels.height);
			offCtx.putImageData(imageData, 0, 0);
			pixels.timestamp = currentTs;
		}

		ctx.drawImage(pixels, x, y);
	}
}

function renderPerfectFrame() {
	const cutoffTs = Number(frameSlider.value),
		canvas = document.createElement("canvas"),
		ctx = canvas.getContext("2d");
	canvas.width = (mx - dx + 1) * 1000;
	canvas.height = (my - dy + 1) * 1000;
	for (const wpls of wplsFiles) {
		const { x, y } = wpls.metadata;
		ctx.putImageData(new ImageData(wpls.toPng(cutoffTs), 1000, 1000), (x - dx) * 1000, (y - dy) * 1000);
	}
	modal.innerHTML = "";
	modal.appendChild(canvas);
	modal.showModal();
}

// batlow
const heatmapPalette = [[1,25,89],[2,27,89],[3,28,90],[4,30,90],[5,31,90],[6,33,91],[7,34,91],[7,36,91],[8,37,91],[9,39,92],[10,40,92],[10,42,92],[11,43,92],[11,45,93],[12,46,93],[12,47,93],[13,49,93],[13,50,94],[13,51,94],[14,53,94],[14,54,94],[14,55,94],[15,56,95],[15,57,95],[15,59,95],[15,60,95],[16,61,95],[16,62,95],[16,63,96],[16,64,96],[17,65,96],[17,66,96],[17,67,96],[17,68,96],[18,69,97],[18,70,97],[18,71,97],[18,72,97],[19,73,97],[19,74,97],[19,75,97],[20,76,98],[20,77,98],[20,78,98],[21,79,98],[21,79,98],[22,80,98],[22,81,98],[23,82,98],[23,83,98],[24,84,98],[24,85,98],[25,86,98],[25,87,98],[26,87,98],[27,88,98],[27,89,98],[28,90,98],[29,91,98],[30,92,98],[30,93,98],[31,93,97],[32,94,97],[33,95,97],[34,96,97],[35,96,96],[36,97,96],[37,98,96],[38,99,95],[39,99,95],[40,100,95],[42,101,94],[43,101,94],[44,102,93],[45,103,93],[47,103,92],[48,104,92],[49,105,91],[51,105,90],[52,106,90],[53,106,89],[55,107,88],[56,108,88],[58,108,87],[59,109,86],[60,109,86],[62,110,85],[63,110,84],[65,111,83],[66,111,82],[68,112,82],[69,112,81],[71,113,80],[72,113,79],[74,114,78],[76,114,77],[77,115,77],[79,115,76],[80,116,75],[82,116,74],[83,117,73],[85,117,72],[87,118,71],[88,118,70],[90,119,69],[91,119,69],[93,120,68],[95,120,67],[96,121,66],[98,121,65],[99,122,64],[101,122,63],[103,123,62],[104,123,62],[106,123,61],[108,124,60],[109,124,59],[111,125,58],[113,125,57],[115,126,56],[116,126,56],[118,127,55],[120,127,54],[121,128,53],[123,128,52],[125,129,52],[127,129,51],[129,130,50],[130,130,49],[132,131,49],[134,131,48],[136,132,47],[138,132,47],[140,133,46],[142,133,46],[143,134,45],[145,134,45],[147,135,44],[149,135,44],[151,136,44],[153,136,44],[155,137,43],[157,137,43],[159,137,43],[161,138,43],[163,138,44],[165,139,44],[167,139,44],[169,140,44],[171,140,45],[173,140,45],[175,141,46],[177,141,47],[179,142,47],[181,142,48],[183,142,49],[185,143,50],[187,143,51],[189,143,52],[190,144,53],[192,144,54],[194,144,55],[196,145,56],[198,145,58],[200,145,59],[202,146,60],[203,146,62],[205,146,63],[207,147,64],[209,147,66],[210,147,67],[212,148,69],[214,148,70],[216,148,72],[217,149,74],[219,149,75],[221,149,77],[222,150,79],[224,150,81],[225,151,82],[227,151,84],[228,151,86],[230,152,88],[231,152,90],[233,153,92],[234,153,94],[235,154,96],[237,154,98],[238,155,100],[239,155,103],[240,156,105],[241,157,107],[242,157,109],[243,158,112],[244,159,114],[245,159,116],[246,160,119],[247,161,121],[248,161,123],[248,162,126],[249,163,128],[249,163,130],[250,164,133],[250,165,135],[251,166,137],[251,166,140],[252,167,142],[252,168,144],[252,169,147],[252,169,149],[253,170,151],[253,171,154],[253,172,156],[253,172,158],[253,173,160],[253,174,162],[253,175,165],[253,175,167],[253,176,169],[253,177,171],[253,178,173],[253,178,175],[253,179,177],[253,180,180],[253,180,182],[253,181,184],[253,182,186],[253,183,188],[253,183,190],[253,184,192],[253,185,194],[253,186,196],[253,186,199],[253,187,201],[253,188,203],[253,188,205],[252,189,207],[252,190,209],[252,191,211],[252,191,214],[252,192,216],[252,193,218],[252,194,220],[252,195,223],[252,195,225],[252,196,227],[252,197,229],[251,198,232],[251,198,234],[251,199,236],[251,200,239],[251,201,241],[251,202,243],[251,202,246],[250,203,248],[250,204,250]]

function renderDeltaHeatmap() {
	const canvas = document.createElement("canvas"),
		ctx = canvas.getContext("2d");

	canvas.width = (mx - dx + 1) * 1000;
	canvas.height = (my - dy + 1) * 1000;

	const activity = new Uint32Array(canvas.width * canvas.height);

	for (const wpls of wplsFiles) {
		const { width, height, x, y } = wpls.metadata,
			offsetX = (x - dx) * 1000,
			offsetY = (y - dy) * 1000;

		for (const [, delta] of wpls.deltas) {
			for (let i = 0; i < delta.length; i++) {
				const packed = delta[i],
					id = packed & 0x3f,
					dyPix = (packed >> 6) & 0x3ff,
					dxPix = (packed >> 16) & 0x3ff,
					px = offsetX + dxPix,
					py = offsetY + dyPix;

				const idx = py * canvas.width + px;
				activity[idx]++;
			}
		}
	}

	let maxActivity = -Infinity;
	for (let i = 0; i < activity.length; i++)
		if (activity[i] > maxActivity) maxActivity = activity[i];

	const imgData = ctx.createImageData(canvas.width, canvas.height),
		pixels = imgData.data;

	for (let i = 0; i < activity.length; i++) {
		const v = activity[i],
			intensity = Math.log1p(v) / Math.log1p(maxActivity);

		const [r, g, b] = heatmapPalette[Math.min(Math.floor(intensity*heatmapPalette.length), heatmapPalette.length - 1)];

		pixels[i * 4 + 0] = r;
		pixels[i * 4 + 1] = g;
		pixels[i * 4 + 2] = b;
		pixels[i * 4 + 3] = 255;
	}

	ctx.putImageData(imgData, 0, 0);
	modal.innerHTML = "";
	modal.appendChild(canvas);
	modal.showModal();
}

modal.addEventListener("mousedown", function(e) {
	if (e.target === e.currentTarget) {
		// apparently this is also true when clicking on the scrollbar
		// so a bound check is ineviatable
		const rect = modal.getBoundingClientRect();
		if (e.clientX < rect.left ||
			e.clientX > rect.right ||
			e.clientY < rect.top ||
			e.clientY > rect.bottom) modal.close();
	}
});

let menuOpened = true,
	menuHeight = menu.clientHeight,
	menuWidth = menu.clientWidth;
function toggleMenu(e) {
	if (menuOpened) {
		menu.style.display = "none";
		menuOpened = false;
		window.removeEventListener("mousedown", toggleMenu);
		return;
	}
	menu.style.left = e.pageX - menuWidth - 10 + "px";
	menu.style.top = e.pageY - menuHeight - 10 + "px";
	menu.style.display = "flex";
	menuOpened = true;
	window.addEventListener("mousedown", toggleMenu);
}
toggleMenu();
menuButton.addEventListener("click", toggleMenu);

function goToTimestamp() {
	const answer = prompt("enter the date in y/m/d h:m:s format"),
		timestamp = Math.floor(Date.parse(answer)/1000);
	if (isNaN(timestamp)) return;
	frameSlider.value = timestamp;
	timestampDisplay.innerText = formatDate(timestamp * 1000);
	renderFrame(timestamp);	
}

function hideUi() {
	toolbar.style.zIndex = -1;
	menu.style.zIndex = -1;
	alert("press any key to show again");
	function showAgain() {
		toolbar.style.zIndex = "";
		menu.style.zIndex = "";
		window.removeEventListener("keydown", showAgain);
	}
	window.addEventListener("keydown", showAgain)
}

function debounce(fn, delay) {
	let timer;
	return (...args) => {
		clearTimeout(timer);
		timer = setTimeout(() => fn(...args), delay);
	}
}

function resizeCanvas() {
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;
}
window.addEventListener("resize", resizeCanvas);

function resetTransforms() {
	trX = 0;
	trY = 0;
	scale = 1;
	scheduleRender(Number(frameSlider.value));
}

function formatDate(t) {
	return new Date(t).toLocaleString(undefined, {
		year: "numeric",
		month: "2-digit",
		day: "2-digit",
		hour: "2-digit",
		minute: "2-digit",
		second: "2-digit"
	});
}
resizeCanvas();
</script>
</body>
</html>
