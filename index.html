<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>cunny</title>
<style>
* {margin:0;padding:0;outline:none;border:none}

body {
	font-family: sans-serif;
	background: var(--bg);
	color: var(--fg);
	margin: 0;
	font-size: 1rem;
	--accent: #63b3ff;
	--bg: #161616;
	--fg: #dde1e6;
	overflow: hidden;
}

canvas {
	background:#f8f4f0;
	display: block;
	image-rendering: pixelated;
	width: 100%;
	height: 100%;
}

.toolbar {
	position: fixed;
	bottom: 1em;
	left: 1em;
	padding: 10px;
	background-color: color-mix(in oklab, var(--bg), white 10%);
	border-radius: 7px;
	display: flex;
	flex-direction: horizontal;
	gap: 20px;
	align-items: center;
}

input[type=file] {opacity:0;position:absolute;width:0;height:0;}

.button {
	border-radius: 7px;
	background-color: var(--accent);
	color: var(--bg);
	padding: 10px;
	font-family: sans-serif;
}

.button:hover { cursor: pointer; }
.button:active { background: color-mix(in oklab, var(--accent), black 10%); }

.toolbar * { min-width: fit-content }

.menu {
	position: fixed;
	background-color: color-mix(in oklab, var(--bg), white 10%);
	padding: 10px;
	border-radius: 7px;
	display: flex;
	flex-direction: column;
	gap: 10px;
}

.menu > div {
	background-color: color-mix(in oklab, var(--bg), white 15%);
	border-radius: 7px;
	padding: 5px;
	cursor: pointer;
}

input[type=range] {
	min-width: 30vw;
}

dialog {
	display: grid;
	place-self: center;
	max-width: 33vw;
	max-height: 50vh;
}

#timestamp {
	font-family: monospace;
}
</style>
</head>
<body>
	<div id="toolbar" class="toolbar">
		<input type="file" id="fileInput" accept=".wpls" multiple/>
		<label for="fileInput" class="button">select file</label>
		<div>time: <span id="timestamp">go select a file</span></div>
		<input type="range" id="frameSlider" min="0" max="0" value="0" style="width:100%" />
		<button class="button" id="menuButton">â€¦</div>
	</div>
	<canvas id="canvas"></canvas>
	<div id="menu" class="menu">
		<div onmousedown="renderPerfectFrame()">render perfect image</div>
		<div onmousedown="goToTimestamp()">go to timestamp</div>
		<div onmousedown="hideUi()">hide ui</div>
	</div>
	<dialog id="modal"></dialog>
<script src="./pako.min.js"></script>
<script src="./wpls.js"></script>
<script>
const canvas = document.getElementById("canvas"),
	ctx = canvas.getContext("2d"),
	fileInput = document.getElementById("fileInput"),
	timestampDisplay = document.getElementById("timestamp"),
	frameSlider = document.getElementById("frameSlider"),
	modal = document.getElementById("modal"),
	menuButton = document.getElementById("menuButton"),
	menu = document.getElementById("menu"),
	toolbar = document.getElementById("toolbar");

let wplsFiles = [],
	maxFrames = 0,
	dx = 0,
	dy = 0,
	mx = 0,
	my = 0,
	lastCutoffTs = 0;

const pixelCache = new Map(),
	pixelBuffers = new Map();

fileInput.addEventListener("change", async (e) => {
	const files = Array.from(e.target.files);
	wplsFiles = [];

	for (const file of files) {
		const buf = new Uint8Array(await file.arrayBuffer());
		const wpls = new WplsFile(buf);
		wplsFiles.push(wpls);
	}

	let earliestTs = Infinity, latestTs = -Infinity, minx = Infinity, miny = Infinity, maxx = -Infinity, maxy = -Infinity;

	for (const file of wplsFiles) {
		const { baseTimestamp, latestTimestamp, x, y } = file.metadata;
		if (baseTimestamp < earliestTs) earliestTs = baseTimestamp;
		if (latestTimestamp > latestTs) latestTs = latestTimestamp;
		if (x < minx) minx = x;
		if (x > maxx) maxx = x;
		if (y < miny) miny = y;
		if (y > maxy) maxy = y;
	}

	frameSlider.min = earliestTs;
	frameSlider.max = latestTs;
	frameSlider.value = latestTs;
	dx = minx;
	mx = maxx;
	dy = miny;
	my = maxy;

	timestampDisplay.innerText = formatDate(latestTs * 1000);

	pixelCache.clear();
	pixelBuffers.clear();

	renderFrame(latestTs);
});

frameSlider.addEventListener("input", debounce(() => {
	const timestamp = Number(frameSlider.value);
	renderFrame(timestamp);
	timestampDisplay.innerText = formatDate(timestamp * 1000);
}, 10));

let trX = 0,
	trY = 0,
	scale = 1;

const pointers = new Map();

canvas.addEventListener("pointerdown", e => {
	e.preventDefault();
	canvas.setPointerCapture(e.pointerId);
	pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
});

canvas.addEventListener("pointermove", e => {
	if (!pointers.has(e.pointerId)) return;
	const prev = pointers.get(e.pointerId);
	pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
	if (pointers.size === 1) {
		const dx = e.clientX - prev.x;
		const dy = e.clientY - prev.y;
		trX += dx;
		trY += dy;
		scheduleRender(Number(frameSlider.value));
	}/* else if (pointers.size === 2) {
		// todo
	}*/
});

canvas.addEventListener("pointerup", e => pointers.delete(e.pointerId));
canvas.addEventListener("pointercancel", e => pointers.delete(e.pointerId));

canvas.addEventListener("wheel", e => {
	e.preventDefault();

	const rect = canvas.getBoundingClientRect(),
		mouseX = e.clientX - rect.left,
		mouseY = e.clientY - rect.top;

	// world coords of cursor BEFORE zoom
	const worldX = (mouseX - trX) / scale,
		worldY = (mouseY - trY) / scale;

	const zoomFactor = e.deltaY < 0 ? 1.111 : 1 / 1.111;
	scale *= zoomFactor;

	// so that worldX/worldY stays under cursor
	trX = mouseX - worldX * scale;
	trY = mouseY - worldY * scale;

	scheduleRender(Number(frameSlider.value));
});


let needsRedraw = false;
function scheduleRender(cutoffTs) {
	lastCutoffTs = cutoffTs;
	if (!needsRedraw) {
		needsRedraw = true;
		requestAnimationFrame(() => {
			needsRedraw = false;
			renderFrame(lastCutoffTs);
		});
	}
}

function renderFrame(cutoffTs) {
	ctx.setTransform(1, 0, 0, 1, 0, 0);
	ctx.clearRect(0, 0, canvas.width, canvas.height);

	ctx.setTransform(scale, 0, 0, scale, trX|0, trY|0);
	ctx.imageSmoothingEnabled = false;

	// compute visible world rect
	const viewX0 = -trX / scale,
		viewY0 = -trY / scale,
		viewX1 = (canvas.width - trX) / scale,
		viewY1 = (canvas.height - trY) / scale;

	for (const wpls of wplsFiles) {
		const x = (wpls.metadata.x - dx) * 1000;
		const y = (wpls.metadata.y - dy) * 1000;

		if (x + 1000 < viewX0 || x > viewX1 || y + 1000 < viewY0 || y > viewY1)
			continue;

		let currentTs = -1;
		for (const [timestamp] of wpls.deltas) {
			if (timestamp > cutoffTs) break;
			currentTs = timestamp;
		}

		const k = wpls.metadata.x + "_" + wpls.metadata.y;
		let pixels = pixelCache.get(k),
			buf = pixelBuffers.get(k);

		if (!buf) {
			buf = new Uint8ClampedArray(1000*1000*4);
			pixelBuffers.set(k, buf);
		}

		if (!pixels) {
			wpls.toPng(currentTs, buf);

			const off = new OffscreenCanvas(1000, 1000),
				offCtx = off.getContext("2d"),
				imageData = new ImageData(buf, 1000, 1000);
			offCtx.imageSmoothingEnabled = false;
			offCtx.putImageData(imageData, 0, 0);
			off.timestamp = currentTs;
			pixels = off;
			pixelCache.set(k, pixels);
		} else if (pixels.timestamp !== currentTs) {
			wpls.toPng(currentTs, buf);

			const offCtx = pixels.getContext("2d"),
				imageData = new ImageData(buf, 1000, 1000);
			offCtx.clearRect(0, 0, pixels.width, pixels.height);
			offCtx.putImageData(imageData, 0, 0);
			pixels.timestamp = currentTs;
		}

		ctx.drawImage(pixels, x, y);
	}
}

function renderPerfectFrame() {
	const cutoffTs = Number(frameSlider.value),
		canvas = document.createElement("canvas"),
		ctx = canvas.getContext("2d");
	canvas.width = (mx - dx + 1) * 1000;
	canvas.height = (my - dy + 1) * 1000;
	for (const wpls of wplsFiles) {
		const { x, y } = wpls.metadata;
		ctx.putImageData(new ImageData(wpls.toPng(cutoffTs), 1000, 1000), (x - dx) * 1000, (y - dy) * 1000);
	}
	modal.innerHTML = "";
	modal.appendChild(canvas);
	modal.showModal();
}

modal.addEventListener("mousedown", function(e) {
	if (e.target === e.currentTarget) {
		// apparently this is also true when clicking on the scrollbar
		// so a bound check is ineviatable
		const rect = modal.getBoundingClientRect();
		if (e.clientX < rect.left ||
			e.clientX > rect.right ||
			e.clientY < rect.top ||
			e.clientY > rect.bottom) modal.close();
	}
});

let menuOpened = true,
	menuHeight = menu.clientHeight,
	menuWidth = menu.clientWidth;
function toggleMenu(e) {
	if (menuOpened) {
		menu.style.display = "none";
		menuOpened = false;
		window.removeEventListener("mousedown", toggleMenu);
		return;
	}
	menu.style.left = e.pageX - menuWidth - 10 + "px";
	menu.style.top = e.pageY - menuHeight - 10 + "px";
	menu.style.display = "flex";
	menuOpened = true;
	window.addEventListener("mousedown", toggleMenu);
}
toggleMenu();
menuButton.addEventListener("click", toggleMenu);

function goToTimestamp() {
	const answer = prompt("enter the date in y/m/d h:m:s format"),
		timestamp = Math.floor(Date.parse(answer)/1000);
	if (isNaN(timestamp)) return;
	frameSlider.value = timestamp;
	timestampDisplay.innerText = formatDate(timestamp * 1000);
	renderFrame(timestamp);	
}

function hideUi() {
	toolbar.style.zIndex = -1;
	menu.style.zIndex = -1;
	alert("press any key to show again");
	function showAgain() {
		toolbar.style.zIndex = "";
		menu.style.zIndex = "";
		window.removeEventListener("keydown", showAgain);
	}
	window.addEventListener("keydown", showAgain)
}

function debounce(fn, delay) {
	let timer;
	return (...args) => {
		clearTimeout(timer);
		timer = setTimeout(() => fn(...args), delay);
	}
}

function resizeCanvas() {
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;
}
window.addEventListener("resize", resizeCanvas);

function formatDate(t) {
	return new Date(t).toLocaleString(undefined, {
		year: "numeric",
		month: "2-digit",
		day: "2-digit",
		hour: "2-digit",
		minute: "2-digit",
		second: "2-digit"
	});
}
resizeCanvas();
</script>
</body>
</html>
